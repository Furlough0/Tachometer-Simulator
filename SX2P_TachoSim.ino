//
// This code is a sketch for an Arduino Uno to act as a tachometer sender.
// The signals output simulate those generated by a Sieg SX2P milling machine.
// It was tested against the SPI_Serial_Reader and generates the 'extra' header data.
// I believe it will work on a number of other mills and lathes but is not tested.

//--------------------------------------
//  Author: Martyn Holliday - 7/10/2019  -->
//--------------------------------------
// Release Version V-1.0
//--------------------------------------

//   Runs on an Arduino UNO board.
//   Emits pulses for testing of the Sieg tachometer (SPI_Serial_Reader).
//   Should also drive the Tachometer software by Jennifer Edwards.
//   Every 750 ms sends 7 frames.
//   Three header frames followed by 4 data frames.
//   Header frame is 12 bits for a total of 36 bits.
//   A data frame is 17 bits for a total of 68 bits.
//   Overall 104 bits.
//   Therefore 104 clock pulses.
//   Note that the Tachometer will signal a communications error if the repetition rate is
//   not close to 750 ms.
//   How close?  Do not know.
//   Be nice if the tachometer sw could ignore long gaps between messages. Hint!

// I hope the code is self explanatory.
// Certainly when coupled to the SPI_Serial_Reader it is easy to observe the results.
// Have fun.

boolean toggle = false;
boolean stopped = false;
int bitCount = 0;    //Which bit are we sending
byte frameCount = 0;  //Which frame are in sending
int pktAds = 0;  //Which frame are in sending
int pktData = 0;  //Which frame are in sending
int out = 13;       //pulse output pin (On board LED)
int tacho_fm_pin = 4;       //Frame output pin
int tacho_ck_pin = 5;       //Clock output pin
int tacho_da_pin = 6;       //Data output pin
int headerByte = 0;
int hc = 0;
int i = 0;
int j = 0;
int k = 0;

//Changing the sequence number here changes the subprocedure used and the 
//data output as a result.
int sequence = 6; 

byte testBits[]    = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
//unsigned int headerData[]   = {0x0012, 0x0345, 0x0678};
unsigned int headerData[]   = {0x0876, 0x0543, 0x0210};
//int packetData[] = {0xBE, 0xBE, 0xBE, 0x08};
//byte seg7[]      = {0xBE, 0xA0, 0xD6, 0xF8, 0xE8, 0x7A, 0x7E, 0xB0, 0xFE, 0xFA};//Reversed bits
//byte seg7[]      = {0x7D, 0x05, 0x6B, 0x4F, 0x17, 0x5E, 0x7E, 0x0D, 0x7F, 0x5F};//Normal !
byte seg7[]        = {0xFA, 0x0A, 0xD6, 0x9E, 0x2E, 0xBC, 0xFC, 0x1A, 0xFE, 0xBE};//shifted bits
byte digits[]      = {0x00, 0x00, 0x00, 0x00};

//------------------------------------------------------------------------
void setup()
{
  pinMode(out, OUTPUT);
  pinMode(tacho_fm_pin, OUTPUT);
  pinMode(tacho_ck_pin, OUTPUT);
  pinMode(tacho_da_pin, OUTPUT);
  Serial.begin(115200);
  k=11;

  delay(1000);     //delay 1 s to allow time to start serial monitor
  sequence = 3;
  Serial.println("\n-----STARTING-----");
}

//------------------------------------------------------------------------
void sequence0()
{
  digits[0] =  0;
  digits[1] =  0;
  digits[2] =  0;
  digits[3] = 0x10;  //x10; //bit reversed 0x20
}

//------------------------------------------------------------------------
void sequence1()
{
  digits[0] = 7;
  digits[1] = 5;
  digits[2] = 1;
  digits[3] = 0x10; //bit reversed 0x20
  if (i < 8)
  {
    i++;
  } else
  {
    i = 0;
  }
  //  digits[3] = 1;  //bit(0);
}
//------------------------------------------------------------------------
void sequence2()
{
  switch (j)
  {
    case 0:
    case 1:
    case 2:
      {
        if (i < 10)
        {
          digits[j] = i;
          i++;

          digits[3] = 0;  //0x10; //bit reversed 0x20
        } else
        {
          digits[j] = 0;
          i = 0;
          j++;
        }
        break;
      }
    case 3:
      {
        j = 0;
        break;
      }
    default:
      i = 0;
      j = 0;
  }
}

//------------------------------------------------------------------------
void sequence3()
{
  switch (j)
  {
    case 0:
    case 1:
    case 2:
      {
        if (i < 10)
        {
          digits[2-j] = i;
          i++;

          //          digits[2] |= 0x10; //bit reversed 0x20
        } else
        {
          digits[2-j] = 0;
          i = 0;
          j++;
        }
        break;
      }
    case 3:
      {
        if (i < 5)
        {
          digits[0] = 0;
          digits[1] = 0;
          digits[2] = 1;
          digits[3]++;
  digits[3] = digits[3]%0x256;
          i++;
        } else
        {
          j++;
          digits[3] = 0x00;
        }
        break;
      }
    case 4:
      {
        if (i < 5)
        {
          digits[0] = 0;
          digits[1] = 0;
          digits[2] = 2;
          digits[3]++;
  digits[3] = digits[3]%0x256;
          i++;
        } else
        {
          i = 0;
          j++;
          TxBit(true);//fake noise
          digits[3] = 0x00;
        }
        break;
      }
    default:
      i = 0;
      j = 0;
  }
}

//------------------------------------------------------------------------
void sequence4()
{
  digits[0] = 6;
  digits[1] = 5;
  digits[2] = 4;
  digits[3] = 0x81;
//  Serial.print("digits[3])=0x");
//  Serial.print(digits[3], HEX);
//  Serial.println("");

  if (i < 8)
  {
    i++;
  } else
  {
    i = 0;
  }
}

//------------------------------------------------------------------------
void sequence5()
{
  digits[0] = 6;
  digits[1] = 5;
  digits[2] = 4;
  digits[3] = 0x81;
  Serial.print("digits[3])=0x");
  Serial.print(digits[3], HEX);
  Serial.println("");

  //  if (i < 8)
  //  {
  //    i++;
  //  } else
  //  {
  //    i = 0;
  //  }
}

//------------------------------------------------------------------------
void sequence6()
{
  digits[0] = 0;
  digits[1] = 0;
  digits[2] = 1;
  digits[3]++;
  digits[3] = digits[3]%0x256;
  Serial.print("digits[3])=0x");
  Serial.print(digits[3], HEX);
  Serial.println("");

  //  if (i < 8)
  //  {
  //    i++;
  //  } else
  //  {
  //    i = 0;
  //  }
}

//------------------------------------------------------------------------
void TxBit(boolean b)
{ //single bit
  cli();//stop interrupts
  if (b)
  { // if bitwise OR resolves to true(high)
    PORTD = bit(tacho_da_pin) | PORTD; //tacho_da_pin
  }
  else
  { //if bitwise AND resolves to false(low)
    PORTD = ~(bit(tacho_da_pin)) & (PORTD); //tacho_da_pin
  }
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  PORTD = ~(bit(tacho_ck_pin)) & (PORTD); //clockPin - LOW
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  PORTD = bit(tacho_ck_pin) | PORTD; //clockPin - HIGH
  sei();//allow interrupts
  //    __asm__("nop\n\t");
  //    __asm__("nop\n\t");
  //    __asm__("nop\n\t");
}

//------------------------------------------------------------------------
void sendHeaderFrame(unsigned int hi)
{ //12 bits
  digitalWrite(tacho_ck_pin, HIGH);
  digitalWrite(tacho_fm_pin, LOW);
  //higher bits first
  for (bitCount = 4; bitCount < 16; bitCount++)
  {
    TxBit((hi & ((unsigned int)0B1000000000000000 >> bitCount)) ? HIGH : LOW);
  }
  PORTD = bit(tacho_ck_pin) | PORTD; //tacho_ck_pin
  PORTD = bit(tacho_da_pin) | PORTD; //tacho_da_pin
  PORTD = bit(tacho_fm_pin) | PORTD; //tacho_fm_pin
  delayMicroseconds(3);
}

//------------------------------------------------------------------------
void sendDataFrame(byte b1, byte b2, boolean stopFlag)
{ //16 bits in 2 parts separated by a 0 bit
  //  Serial.print("stopFlag=");Serial.println(stopFlag);
  //  digitalWrite(tacho_ck_pin, HIGH);
  //  digitalWrite(tacho_fm_pin, LOW);
  //address part

  //  delayMicroseconds(1);
  for (bitCount = 0; bitCount < 8; bitCount++)
  {
    TxBit((b1 & ((unsigned byte)0B10000000 >> bitCount)) ? HIGH : LOW);
  }

  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //    delayMicroseconds(1);
  //This bit is always 0
  TxBit(0);

  //Data part, send seven bits
  for (bitCount = 0; bitCount < 7; bitCount++)
  {
    TxBit((b2 & (unsigned byte)((unsigned byte)0B10000000 >> bitCount)) ? HIGH : LOW);
    //TxBit(LOW);
  }

  //This bit in frame 2 is always 0 unless spindle is stopped
  TxBit(stopFlag);

  PORTD = bit(tacho_ck_pin) | PORTD; //tacho_ck_pin
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //  __asm__("nop\n\t");
  //    delayMicroseconds(1);//10,4,2 is good 1 is bad
  //  PORTD = bit(tacho_da_pin) | PORTD; //tacho_da_pin
  PORTD = bit(tacho_fm_pin) | PORTD; //tacho_fm_pin
  //  delayMicroseconds(3);
}

//------------------------------------------------------------------------
void sendHexFrame(byte b1, byte b2)
{ //16 bits in 2 parts separated by a 0 bit
  //  Serial.print("stopFlag=");Serial.println(stopFlag);
  //  digitalWrite(tacho_ck_pin, HIGH);
  //  digitalWrite(tacho_fm_pin, LOW);
  //address part

  delayMicroseconds(1);
  for (bitCount = 0; bitCount < 8; bitCount++)
  {
    TxBit((b1 & ((unsigned byte)0B10000000 >> bitCount)) ? HIGH : LOW);
  }

  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  delayMicroseconds(1);
  //This bit is always 0
  TxBit(0);

  //Data part, send seven bits
  for (bitCount = 0; bitCount < 8; bitCount++)
  {
    TxBit((b2 & (unsigned byte)((unsigned byte)0B10000000 >> bitCount)) ? HIGH : LOW);
    //TxBit(LOW);
  }

  PORTD = bit(tacho_ck_pin) | PORTD; //tacho_ck_pin
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  __asm__("nop\n\t");
  delayMicroseconds(2);//10,4,2 is good 1 is bad
  PORTD = bit(tacho_da_pin) | PORTD; //tacho_da_pin
  PORTD = bit(tacho_fm_pin) | PORTD; //tacho_fm_pin
  delayMicroseconds(3);
}

//------------------------------------------------------------------------
void sendPackets()
{
  digitalWrite(tacho_fm_pin, HIGH);
  digitalWrite(tacho_ck_pin, HIGH);
  digitalWrite(tacho_da_pin, HIGH);
  sendHeaderFrame(headerData[0]);
  sendHeaderFrame(headerData[1]);
  sendHeaderFrame(headerData[2]);
  delayMicroseconds(82);  //To mimic the Tx pause from a real Mill

  stopped = false;
  if (digits[0] == 0  && digits[1] == 0 && digits[2] == 0)
  {
    stopped = true;
  }
  sendDataFrame(0xA0, seg7[digits[0]], false);
  sendDataFrame(0xA1, seg7[digits[1]], false);
  sendDataFrame(0xA2, seg7[digits[2]], stopped);
  delayMicroseconds(27);  //To mimic the Tx pause from a real Mill
  sendHexFrame(0xA3, digits[3]);
}

//-----------------------------------------------------------------------------------------------------
// 100000 ~= 88ms, 100 ~= 88us, 114 ~= 100us
void block_delay(unsigned long units)
{
  unsigned long i;
  for (i = 0; i < 1980; i++)
  {
    unsigned long j;
    for (j = 0; j < units; j++)
    { // 100000 ~= 88ms, 100 ~= 88us, 114 ~= 100us
      // a "nop" takes one clock cycle ~= 1/16us
      asm("nop"); // Stop optimizations
    }
  }
}

//------------------------------------------------------------------------
void CrankHeader()
{
  if (headerData[2] == 0xFFF)
  {
    headerData[2] == 0;
    if (headerData[1] == 0xFFF)
    {
      headerData[1] == 0;
      if (headerData[0] == 0xFFF)
      {
        headerData[0] == 0;
      } else
      {
        headerData[0] += 1;
      }
    } else
    {
      headerData[1] += 1;
    }
  } else
  {
    headerData[2] += 1;
  }
}

//------------------------------------------------------------------------
void sendHexPackets()
{
  digitalWrite(tacho_fm_pin, HIGH);
  digitalWrite(tacho_ck_pin, HIGH);
  digitalWrite(tacho_da_pin, HIGH);
  sendHeaderFrame(headerData[0]);
  sendHeaderFrame(headerData[1]);
  sendHeaderFrame(headerData[2]);
  delayMicroseconds(82);  //To mimic the Tx pause from a real Mill
  sendHexFrame(0x00, digits[0]);
  sendHexFrame(0x00, digits[1]);
  sendHexFrame(0x00, digits[2]);
  delayMicroseconds(27);  //To mimic the Tx pause from a real Mill
  sendHexFrame(0x00, digits[3]);
}

//------------------------------------------------------------------------
void loop()
{
  digitalWrite(out, HIGH);
  block_delay(300); // ~300ms delay
  //  delay(200);
  digitalWrite(out, LOW);
  block_delay(200); // ~300ms delay
  //  delay(200);

  switch (sequence)
  {
    case 0:
      sequence0();
      break;
    case 1:
      sequence1();
      break;
    case 2:
      sequence2();
      break;
    case 3:
      sequence3();
      break;
    case 4:
      sequence4();
      break;
    case 5:
      sequence5();
      break;
    case 6:
      sequence6();
      break;
    default:
      sequence0();
  }
  //    sendHexPackets();
  sendPackets();
  CrankHeader();
////  k++;
//  k= 8%k;
//   Serial.print("k=");
//   Serial.println (k);
      
}//End loop

//End File
